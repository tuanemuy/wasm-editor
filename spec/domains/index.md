# ドメイン設計

## 概要

本アプリケーションは Domain-Driven Design (DDD) の原則に従って設計されています。
ビジネスロジックはドメイン層に集約され、外部システムとの依存関係はポート/アダプターパターンで管理されます。

## アーキテクチャ

```
app/core/
├── domain/           # ドメイン層
│   ├── ${domain}/
│   │   ├── entity.ts           # エンティティ
│   │   ├── valueObject.ts      # 値オブジェクト
│   │   ├── errorCode.ts        # エラーコード
│   │   └── ports/              # ポート (インターフェース)
│   └── error.ts                # ドメイン共通エラー
├── application/      # アプリケーション層
│   ├── ${domain}/
│   │   └── ${usecase}.ts       # ユースケース
│   ├── context.ts              # DIコンテキスト
│   ├── unitOfWork.ts           # UnitOfWorkパターン
│   └── error.ts                # アプリケーション層エラー
└── adapters/         # アダプター層
    └── ${provider}/            # 外部サービス実装
```

## ドメイン一覧

本アプリケーションは以下の3つのドメインで構成されます：

### 1. Note (メモ)

メモの作成、編集、削除、閲覧、検索を担当するコアドメイン。

**責務:**
- メモのライフサイクル管理
- メモの検証とビジネスルール適用
- メモの検索とフィルタリング
- メモのエクスポート

**詳細:** [spec/domains/note.md](./note.md)

### 2. Tag (タグ)

タグの自動解析、管理を担当するサポートドメイン。

**責務:**
- メモ本文からのタグ自動解析
- タグの一覧表示（使用回数は集計結果として計算）
- タグとメモの関連付け管理
- 未使用タグのクリーンアップ

**詳細:** [spec/domains/tag.md](./tag.md)

### 3. Settings (設定)

アプリケーション全体の設定を管理する汎用ドメイン。

**責務:**
- アプリケーション設定の永続化
- 設定の検証
- デフォルト値の管理

**詳細:** [spec/domains/settings.md](./settings.md)

## ドメイン間の関係

```
┌─────────────┐
│   Settings  │  (独立)
└─────────────┘

┌─────────────┐      ┌─────────────┐
│     Note    │─────▶│     Tag     │
└─────────────┘      └─────────────┘
  (コア)              (サポート)
  集約ルート           集約ルート
```

- **Note → Tag**:
  - Noteは複数のTagへの参照を持つ（`tagIds: TagId[]`）
  - NoteがTagへの関連を所有する（多対多の関係）
  - Note集約がタグIDのリストを管理
  - タグからメモを検索する機能は`NoteQueryService`が提供
- **Settings**:
  - 他のドメインから独立して動作
  - 単独の集約
- **Tag**:
  - 独立した集約ルートとして存在
  - Noteから参照されるが、独自のライフサイクルを持つ
  - タグの作成・削除は独立して管理される
  - NoteIdへの依存はない

### 集約の設計原則

1. **Note集約**:
   - メモ本文とタグIDのリストを所有
   - タグIDのリストの変更はNote集約の一部として管理
   - NoteRepositoryがメモとタグIDリストを永続化

2. **Tag集約**:
   - タグの名前と属性を所有
   - TagRepositoryがタグを永続化
   - メモとの関連は管理しない（NoteRepositoryが管理）

3. **Settings集約**:
   - アプリケーション設定を所有
   - 他の集約から独立
   - システム全体で単一の設定インスタンスが永続化される（リポジトリ層で保証）

## 設計原則

### ドメイン層

1. **ビジネスルールの集約**: すべてのビジネスロジックはドメイン層に配置
2. **外部依存の排除**: 外部システム (DB, API等) への直接的な依存を持たない
   - 外部ライブラリが必要な場合はポートとして抽象化する
3. **不変性の維持**: 値オブジェクトは不変 (immutable) とする
4. **型安全性**: ブランド型を使用して型の誤用を防止

### アプリケーション層

1. **ユースケースの独立性**: 各ユースケースは独立した関数として実装
2. **トランザクション管理**: UnitOfWorkパターンでトランザクションを管理
3. **エラーハンドリング**: ドメインエラーを適切なアプリケーションエラーに変換

### アダプター層

1. **ポートの実装**: ドメイン層で定義されたポートを実装
2. **外部システムの抽象化**: 外部システムの詳細をドメイン層から隠蔽
3. **エラー変換**: 外部システムのエラーをドメイン/アプリケーションエラーに変換
4. **リポジトリの責務**: **Repositoryは集約の永続化のみを担当**
   - **集約ルートに対してのみRepositoryを作成**する
   - 集約の CRUD 操作と基本的なクエリのみを実装
   - ビジネスロジックは含めない（エンティティの状態変更はドメイン層で実行）
   - 集約が所有する関連データも含めて永続化する
   - **集約間の関連付け管理はRepositoryの責務ではない**
   - **中間テーブルの扱い**:
     - 集約が他の集約への参照を持つ場合、IDの配列として表現する（例: `Note.tagIds: TagId[]`）
     - 中間テーブル（例: `noteTagRelations`）は実装詳細であり、ドメインエンティティではない
     - 中間テーブルは集約を所有するRepositoryが内部的に管理する
     - 例: `NoteRepository` が `Note` とその `tagIds` を永続化する際、内部で `noteTagRelations` テーブルを操作
     - 中間テーブルに対して独立したRepositoryは作成しない
5. **QueryService パターン**: 複雑な検索クエリは専用のサービスで実装
   - **読み取り専用**の複雑なクエリを分離
   - 複数エンティティを横断する JOIN クエリを実装
   - データベースレベルでの最適化を許容
   - 効率的なページネーション、集計、複合検索を実現
   - Repository は単一集約の CRUD とシンプルな検索を担当
   - QueryService は JOIN が必要な複雑な検索、集計、複合検索を担当
   - 例: `TagQueryService.findAllWithUsage()` は `tags` と `noteTagRelations` をJOINして使用回数を集計

## 参考資料

- 実装例: [docs/implementation_example.md](../docs/implementation_example.md)
- 要件定義: [spec/requirements.md](../requirements.md)
- ページ構成: [spec/pages.md](../pages.md)
